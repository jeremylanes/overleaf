/**
 * Cache class allowing to create caches with automatic cache loading and delegates.
 */
export declare abstract class BaseCacheLoader<K, V> {
    private readonly cacheDefinition;
    private readonly cacheOptions;
    private delegate;
    private mode;
    protected isCacheable: boolean;
    /**
     * Constructor.
     *
     * @param {String} cacheId the identifier of the cache
     * @param {Object} cacheOptions the cache options:
     * * {Number} expirationTime: cache entries expiration time (seconds)
     * * {Number} maxSize: maximum number of cache entries
     */
    protected constructor(cacheId: string, { expirationTime, maxSize }?: CacheOptions);
    protected abstract load(key: K): Promise<V>;
    /**
     * Gets a cached value.
     *
     * @param {K} key the cache key
     * @param {Boolean} force whether to force the cache refresh for that key (default: false)
     * @return {Promise<V>} the cached value
     */
    get(key: K, force?: boolean): Promise<V>;
    /**
     * @override
     *
     * Gets a cached value with additional metadata.
     *
     * @param {K} key the cache key
     * @param {Boolean} force whether to force the cache refresh for that key (default: false)
     * @return {Promise<Metadata<V>>} the cached value
     */
    getWithMetadata(key: K, force?: boolean): Promise<Metadata<V>>;
    set(key: K, value: V): Promise<void>;
    /**
     * Checks if a cache entry exists for a given key.
     *
     * @param {String} key
     * @return {Boolean} true if the entry exists in the cache, false otherwise
     */
    exists(key: K): Promise<boolean>;
    /**
     * Deletes a cache entry for a given key.
     *
     * @param {String} key
     */
    delete(key: K): Promise<void>;
    /**
     * Deletes all entries in the cache;
     */
    reset(): Promise<void>;
    getCacheId(): string;
    getCacheDefinition(): CacheDefinition;
    protected keyToString(key: K): string;
    protected serialize(value: V): any;
    protected deserialize(value: any): V;
    protected addMetadata(metadata: CacheMetadata): void;
    private doLoadAndSet;
    private switchToLRUMode;
    private switchToRedisMode;
}
export interface CacheOptions {
    expirationTime?: number;
    maxSize?: number;
}
interface Metadata<V> {
    value: V;
    cached: boolean;
    time: number;
}
export interface CacheDefinition {
    id: string;
    options: {
        expirationTime: string;
        maxSize: number;
    };
    metadata: CacheMetadata;
}
interface CacheMetadata {
    type?: string;
    class?: string;
}
export {};
